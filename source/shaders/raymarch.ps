struct ps_in
{
	float4		Position : SV_Position;
};

struct probe
{
	float3		Position;
	float		Transmittance;
};

cbuffer ModelParams : register(b0)
{
	float4x4		World,
					View,
					Proj;
};

cbuffer raymarch_params : register(b1)
{
	uint		ScreenWidth;
	uint		ScreenHeight;
	float		MinVal;
	float		MaxVal;
	float3		LightPos;
	float 		Absorption;
	float 		DensityScale;
	int			UseProbes;
};

cbuffer grid_params : register(b2)
{
	int3		GridDims;
	uint		ProbeCount;
	float3		GridMin;
	float3		GridMax;
	float3		GridExtents;
	float3		GridExtentsRcp;
	float3		CellSize;
};

static const uint MaxIterations = 64;
#define DARKNESS_THRESHOLD	0.2

Texture3D<float>		Volume : register(t0);
Texture2D<float4>		FrontPositions : register(t1); // frontface-culled, so backface
Texture2D<float4>		BackPositions : register(t2);  // backface-culled, so frontface
Texture1D<float4>		Colormap : register(t3);
SamplerState			LinearSampler : register(s0);
StructuredBuffer<probe>	Probes : register(t4);

float4		Accumulate(float4 Color, float4 NewColor, float Brightness);
float		HenyeyGreenstein(float a, float g);
float		Rayleigh(float a);
float4		CastRay(float3 RayOrigin, float3 RayDirection, float tMin, float tMax, float dt);
float4		CastRayMIP(float3 RayOrigin, float3 RayDirection, float tMin, float tMax, float dt);
float4		CastRayLight(float3 RayOrigin, float3 RayDirection, float tMin, float tMax, float dt);
float4x4 	inverse(float4x4 m);

#define probe_index		uint
#define grid_coord		uint3

grid_coord	BaseGridCoord(float3 Pos);
grid_coord	ProbeIndexToGridCoord(probe_index Idx);
probe_index	GridCoordToProbeIndex(grid_coord ProbeCoord);
float3		GridCoordToPosition(grid_coord Coord);
float		LookupProbeData(float3 Pos);

float4
main(ps_in Input) : SV_Target
{
	float2		Tex;
	float3		PosFront,
				PosBack,
				Dir;

	Tex = Input.Position.xy / float2(ScreenWidth, ScreenHeight);

	PosFront = FrontPositions.Sample(LinearSampler, Tex).xyz;
	PosBack = BackPositions.Sample(LinearSampler, Tex).xyz;

	Dir = normalize(PosBack - PosFront);

	float tMin = 0;
	float tMax = length(PosFront - PosBack);
	float dt = length(PosFront - PosBack) / MaxIterations;

	float4 Color = CastRayLight(PosFront, Dir, tMin, tMax, dt);

	return (Color);
}

float4
CastRay(float3 RayOrigin,
		float3 RayDirection,
		float tMin,
		float tMax,
		float dt)
{
	float t = tMin;
	float4 Color = float4(0, 0, 0, 0);
	float4x4 InvWorld = inverse(World);

	[loop]
	while (t < tMax)
	{
		float3 Pos = mul(InvWorld, float4(RayOrigin + t * RayDirection, 0)).xyz;
		float Density = Volume.Sample(LinearSampler, Pos, int3(0, 0, 0));
		float NormalizedDensity = (Density - MinVal) / (MaxVal - MinVal);

		float4 SampledColor = float4(Colormap.Sample(LinearSampler, NormalizedDensity).rgb, 10 * dt);

		Color = Accumulate(Color, SampledColor, 1);

		t += dt;
	}

	return (Color);
}

float4
CastRayMIP(float3 RayOrigin,
		   float3 RayDirection,
		   float tMin,
		   float tMax,
		   float dt)
{
	float t = tMin;
	float MaxDensity = -1000;

	[loop]
	while (t < tMax)
	{
		float3 Pos = RayOrigin + t * RayDirection;
		float Density = Volume.Sample(LinearSampler, Pos, int3(0, 0, 0));
		float NormalizedDensity = (Density - MinVal) / (MaxVal - MinVal);

		if (NormalizedDensity > MaxDensity)
		{
			MaxDensity = NormalizedDensity;
		}

		t += dt;
	}

	float3 SampledColor = Colormap.Sample(LinearSampler, MaxDensity).rgb;
	float4 Color = float4(SampledColor, 1.0);

	return (Color);
}

float4
Accumulate(float4 Color,
		   float4 NewColor,
		   float Brightness)
{
	float OldAlpha = 1.0 - Color.a;
	float NewAlpha = min(1.0, NewColor.a * Brightness);

	return (Color + float4(NewColor.rgb, 1.0) * OldAlpha * NewAlpha);
}

float
Lightmarch(float3 Pos)
{
	float3		LightDir = normalize(LightPos - Pos);
	float		StepSize = length(LightPos - Pos) / float(MaxIterations);
	float		TotalDensity = 0;
	float4x4 	InvWorld = inverse(World);


	for (uint i = 0; i < MaxIterations; i++)
	{
		float3 InvPos = mul(InvWorld, float4(Pos, 1)).xyz;
		float Density = DensityScale * Volume.Sample(LinearSampler, InvPos, int3(0, 0, 0));
		/* float NormalizedDensity = (Density - MinVal) / (MaxVal - MinVal); */

		TotalDensity += Density * StepSize;

		Pos += StepSize * LightDir;
	}
	
	float Transmittance = exp(-TotalDensity * Absorption);

	return (DARKNESS_THRESHOLD + Transmittance * (1 - DARKNESS_THRESHOLD));
}

float4
CastRayLight(float3 RayOrigin,
			 float3 RayDirection,
			 float tMin,
			 float tMax,
			 float dt)
{
	float 		Transmittance = 1;
	float		LightEnergy = 0;
	float 		t = tMin;
	float4x4 	InvWorld = inverse(World);


	[loop]
	while (t < tMax)
	{
		// Need to undo the World transform to stay in bounds of the cube for
		// sampling
		float3 Pos = RayOrigin + t * RayDirection;
		float3 InvPos = mul(InvWorld, float4(RayOrigin + t * RayDirection, 1)).xyz;

		float Density = DensityScale * Volume.Sample(LinearSampler, InvPos, int3(0, 0, 0));
		if (Density > 0)
		{
			float LightTransmittance;

			if (UseProbes)
			{
				LightTransmittance = LookupProbeData(Pos);
			}
			else
			{
				LightTransmittance = Lightmarch(Pos);
			}

			LightEnergy += Density * dt * Transmittance * LightTransmittance;

			Transmittance *= exp(-Density * dt * Absorption);
		}

		t += dt;
	}

	float4 Color = float4(LightEnergy, LightEnergy, LightEnergy, 1 - Transmittance);
	
	return (Color);
}

float
Rayleigh(float a)
{
	return ((3.0f / 16.0f) * (1 + a * a));
}

float
HenyeyGreenstein(float a,
				 float g)
{
	float g2 = g * g;

	return (1 - g2) / (4 * 3.1415 * pow(1 + g2 - 2 * g * a, 1.5f));
}

float4x4 inverse(float4x4 m)
{
    float n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];
    float n21 = m[0][1], n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];
    float n31 = m[0][2], n32 = m[1][2], n33 = m[2][2], n34 = m[3][2];
    float n41 = m[0][3], n42 = m[1][3], n43 = m[2][3], n44 = m[3][3];

    float t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    float t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    float t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    float t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    float det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    float idet = 1.0f / det;

    float4x4 ret;

    ret[0][0] = t11 * idet;
    ret[0][1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * idet;
    ret[0][2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * idet;
    ret[0][3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * idet;

    ret[1][0] = t12 * idet;
    ret[1][1] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * idet;
    ret[1][2] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * idet;
    ret[1][3] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * idet;

    ret[2][0] = t13 * idet;
    ret[2][1] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * idet;
    ret[2][2] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * idet;
    ret[2][3] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * idet;

    ret[3][0] = t14 * idet;
    ret[3][1] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * idet;
    ret[3][2] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * idet;
    ret[3][3] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * idet;

    return ret;
}

grid_coord
BaseGridCoord(float3 Pos)
{
	float3			NormalizedPos = (Pos - GridMin) * GridExtentsRcp;
	grid_coord		Coord = floor(NormalizedPos * (GridDims - 1));

	return (Coord);
}

grid_coord
ProbeIndexToGridCoord(probe_index Idx)
{
	uint z = Idx / (GridDims.x * GridDims.y);
	Idx -= (z * GridDims.x * GridDims.y);
	uint y = Idx / GridDims.x;
	uint x = Idx % GridDims.x;

	return (grid_coord(x, y, z));
}

probe_index
GridCoordToProbeIndex(grid_coord ProbeCoord)
{
	return ((ProbeCoord.z * GridDims.x * GridDims.y) + (ProbeCoord.y * GridDims.x) + ProbeCoord.x);
}

float3
GridCoordToPosition(grid_coord Coord)
{
	return (GridMin + CellSize * Coord);
}

float
LookupProbeData(float3 Pos)
{
	grid_coord		BaseCoord = BaseGridCoord(Pos);
	float3 			BaseProbePos = GridCoordToPosition(BaseCoord);
	float3 			Alpha = saturate((Pos - BaseProbePos) / CellSize);
	float 			LightTransmittance = 0;


	for (uint i = 0; i < 8; i++)
	{
		uint3 Offset = uint3(i, i >> 1, i >> 2) & 1;
		uint Idx = GridCoordToProbeIndex(BaseCoord + Offset);
		probe Probe = Probes[Idx];
		float3 Trilinear = lerp(1.0f - Alpha, Alpha, Offset);
		float Weight = max(0.00001, Trilinear.x * Trilinear.y * Trilinear.z);

		LightTransmittance += Weight * Probe.Transmittance;
	}

	return (LightTransmittance);
}

